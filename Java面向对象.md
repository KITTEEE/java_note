

## Java 面向对象

#### 类和对象的区别

类是对某一类事物的具体描述，而对象用于表示现实中该类事物的个体。例如一个玩具模型可以做成不同的玩具，其中，玩具模型就可以看作类，而玩具就可以看作对象。



#### 局部变量和成员变量的区别

**区别一：定义位置不同**

局部变量一般定义在方法中或者{}语句里，成员变量一般定义在类中。

**区别二：在内存中的位置不同**

局部变量存储在栈内存的方法中，成员变量存储在堆内存的对象中。

**区别三：声明周期不同**

局部变量随着方法运行出现在栈中，随着方法弹栈而消失。

成员变量随着对象的出现而出现在堆中，随着对象的消失而从堆中消失。

**区别四：初始化不同**

局部变量初始化后没有默认值，须手动赋值后才能使用。成员变量有默认的初始化值，因为在堆内存中。



### 封装

#### 封装的概念

封装是 java 面向对象中的一个重要概念，像机箱里有很多像 CPU 或 主板这样重要的组件，将这些重要组件封装起来，仅仅向外暴露其插口。封装的意思和机箱同理：即只向外提供功能的访问方式，隐藏自己内部的实现细节。使用封装可以提高代码的复用性和安全性。



#### 私有 private

一般我们在创建一个类的对象的时候，对象的属性是都可以直接访问的。private 就是可以让对象的某个属性不能被直接访问的修饰符。

用 private 修饰的变量如果要进行访问，可以用封装的思想，只向外提供访问方式。一般对私有的变量 xxx 的访问方式可以提供对应的 setXxx(赋值)方法 或者 getXxx(取值)方法。



#### this关键字 

**成员变量和局部变量同名问题**

在方法中出现了局部变量和成员变量同名的时候，可以在成员变量名前面加上 this. 来区别成员变量和局部变量

**this 代表的是对象，哪个对象调用了 this 所在的方法，this 代表的就是哪个对象。**例如 p.setAge(30) 语句中，setAge(int age) 方法中的 this 代表的就是 对象 p 。



### 继承

**继承描述的是事物之间的所属关系。**例如公司有员工，而员工又可以分为研发部员工或者维护部员工，研发部员工里又可以包含各种不同的工程师，这样在程序中可以描述为研发部员工和维护部员工继承自员工，各种不同的工程师继承自研发部员工或者维护部员工。

继承时需要使用 extends 关键字。一般把继承的类成为子类，被继承的类称为父类，继承之后，子类能拥有父类所有可继承的属性和方法。



#### 继承的注意事项

Java 中只支持单继承，不允许多继承。

多个类可以继承同一个父类。

Java 中允许多层继承，即 B 可继承 A ，C 可继承 B。



#### 继承中，子父类成员变量的特点

* 父类中的成员变量是非私有的，子类可以直接访问，若父类中的成员变量是私有的，则子类不能直接访问。

* 当父类和子类出现了同名的成员变量时，若子类要访问父类的同名成员变量，需使用 super 关键字来完成。表示当前对象引用了父类对象空间。

  ```java
  class Fu { int num = 5; }
  class Zi { 
      int num = 6;
      void show(){
          System.out.println("Fu num ="  + super.num);//访问父类非私有同名成员变量
          System.out.println("Zi num =" + this.num);
      }
  }
  ```



#### 继承中，子父类成员方法的特点(重写等)

**当对象调用方法时，会先在子类中查找有无相应的方法，若存在则会执行子类中的方法，若不存在则会执行父类中相应的方法。**

**方法重写**

**当子类中出现与父类一摸一样的方法时(方法名，参数都相同)，会出现方法的重写(overrride)操作。**子类有自己特有的内容时可以采用重写。

```java
//比如手机来电显示功能，原来只能显示 电话号码，但后期需要在来电显示功能中增加头像和姓名，这时可以重新定义一个描述手机的类并继承原有的类，并重写来电显示功能方法。
class Phone {
    public void showNum() {
        syso("显示号码")；
    }
}
class NewPhone extends Phone {
    public void showNum() {
        super.showNum();//调用父类方法
        syso("显示头像")；
        syso("显示姓名")；
    }
}
```

**方法重写注意事项**

* 子类方法覆盖父类方法，要保证权限大于或等于父类权限

  ```java
  class Fu() { 
      void show(){}
  	public void method() {}
  }
  class Zi extends Fu() {
      public void show() {} //可编译运行
      void method() {} //权限小于父类，编译出错
  }
  ```

* 重写时，方法的返回值类型，方法名，参数列表都要一样。



### 抽象类

有时候，某个父类只知道子类应包含怎样的方法，而不清楚子类会如何实现这些方法。就像一个图形的类，有一个求周长的方法，而不同图形求周长的算法不一样。这时我们便可以考虑把图形类当作一个抽象类。

分析事物时发现了共性的内容时，就可以进行向上抽取，只抽取方法声明而不抽取方法主题，则该被抽取出来的方法便是一个抽象方法。**因此抽象方法只有声明，没有方法体。**

```java
//以研发部员工的共同行为"工作"为例
abstract class Developer {
    public abstract void work();//抽象方法，用 abstract 修饰
}
class JavaEE extends Developer {
    public void work() {...//进行方法主体编写}
}
class Android extends Developer {
	public void work() {...//进行方法主体编写}       
}
```



#### 抽象类的特点

* 抽象类和抽象方法都需要被 abstract 修饰
* 抽象类不可以创建对象，因为调用抽象方法没有意义
* **继承了抽象类的子类，只有重写了所有的抽象方法后，这个子类才可以创建对象，否则这个子类还是一个抽象类。**
* 抽象类一定是一个父类。
* 抽象类中可以不定义抽象方法。（这样做的意义是不会让其他人直接创建该类的对象，）
* 抽象类不可以和 private(私有方法子类继承不到，也就无法重写)、final、static 关键字共存.



什么鬼啊，测试一下